\subsection{Case Study: Deploying releases to JupyterLab}

As our exploration of JupyterLab as the interactive notebook component
of the LSST Science Platform proceeds, we have realized the need for
automated deployments of the lab environment, which is simply a
Kubernetes cluster and namespace.  Automated deployment serves two
purposes: first, it makes it possible to immediately QA changes to the
lab environment itself, since the deployment can become part of a CI
process.  Second, it makes the process of standing up an environment for
a tutorial session or a conference extremely easy.  Our initial version
of the automated deployment tool relies on Google Compute Engine as the
back end, AWS Route 53 as the DNS provider, and either Github or CILogon
as the OAuth2 provider.  We will add more options as demand warrants.
The deployment tool basically provides a sequencer around gcloud,
kubectl, and awscli.  It is driven from a YAML file, from environment
variables, or from the command line.  The way the current version works
is to substitute templated values from its configuration, and then run
gcloud and kubectl to create the various components of the lab
installation.  Future improvements may include a move to Helm charts
rather than raw kubernetes YAML, a rewrite so that deployment becomes a
Terraform configuration rather than a python module, and/or integration
of TLS certificate management into the tool.



Link to main JupyterLab paper by Frossie et al.
